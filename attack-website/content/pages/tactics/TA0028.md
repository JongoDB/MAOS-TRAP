Title: Persistence-mobile
Template: tactics/tactic
save_as: tactics/TA0028/index.html
data: {"attack_id": "TA0028", "name": "Persistence", "name_lower": "persistence", "side_menu_data": {"name": "tactics", "id": "tactics", "path": null, "children": [{"name": "Enterprise", "id": "enterprise", "path": "/tactics/enterprise/", "children": [{"name": "Reconnaissance", "id": "Reconnaissance", "path": "/tactics/TA0043/", "children": []}, {"name": "Resource Development", "id": "Resource Development", "path": "/tactics/TA0042/", "children": []}, {"name": "Initial Access", "id": "Initial Access", "path": "/tactics/TA0001/", "children": []}, {"name": "Execution", "id": "Execution", "path": "/tactics/TA0002/", "children": []}, {"name": "Persistence", "id": "Persistence", "path": "/tactics/TA0003/", "children": []}, {"name": "Privilege Escalation", "id": "Privilege Escalation", "path": "/tactics/TA0004/", "children": []}, {"name": "Defense Evasion", "id": "Defense Evasion", "path": "/tactics/TA0005/", "children": []}, {"name": "Credential Access", "id": "Credential Access", "path": "/tactics/TA0006/", "children": []}, {"name": "Discovery", "id": "Discovery", "path": "/tactics/TA0007/", "children": []}, {"name": "Lateral Movement", "id": "Lateral Movement", "path": "/tactics/TA0008/", "children": []}, {"name": "Collection", "id": "Collection", "path": "/tactics/TA0009/", "children": []}, {"name": "Command and Control", "id": "Command and Control", "path": "/tactics/TA0011/", "children": []}, {"name": "Exfiltration", "id": "Exfiltration", "path": "/tactics/TA0010/", "children": []}, {"name": "Impact", "id": "Impact", "path": "/tactics/TA0040/", "children": []}]}, {"name": "Mobile", "id": "mobile", "path": "/tactics/mobile/", "children": [{"name": "Initial Access", "id": "Initial Access", "path": "/tactics/TA0027/", "children": []}, {"name": "Execution", "id": "Execution", "path": "/tactics/TA0041/", "children": []}, {"name": "Persistence", "id": "Persistence", "path": "/tactics/TA0028/", "children": []}, {"name": "Privilege Escalation", "id": "Privilege Escalation", "path": "/tactics/TA0029/", "children": []}, {"name": "Defense Evasion", "id": "Defense Evasion", "path": "/tactics/TA0030/", "children": []}, {"name": "Credential Access", "id": "Credential Access", "path": "/tactics/TA0031/", "children": []}, {"name": "Discovery", "id": "Discovery", "path": "/tactics/TA0032/", "children": []}, {"name": "Lateral Movement", "id": "Lateral Movement", "path": "/tactics/TA0033/", "children": []}, {"name": "Collection", "id": "Collection", "path": "/tactics/TA0035/", "children": []}, {"name": "Command and Control", "id": "Command and Control", "path": "/tactics/TA0037/", "children": []}, {"name": "Exfiltration", "id": "Exfiltration", "path": "/tactics/TA0036/", "children": []}, {"name": "Impact", "id": "Impact", "path": "/tactics/TA0034/", "children": []}, {"name": "Network Effects", "id": "Network Effects", "path": "/tactics/TA0038/", "children": []}, {"name": "Remote Service Effects", "id": "Remote Service Effects", "path": "/tactics/TA0039/", "children": []}]}, {"name": "ICS", "id": "ics", "path": "/tactics/ics/", "children": [{"name": "Initial Access", "id": "Initial Access", "path": "/tactics/TA0108/", "children": []}, {"name": "Execution", "id": "Execution", "path": "/tactics/TA0104/", "children": []}, {"name": "Persistence", "id": "Persistence", "path": "/tactics/TA0110/", "children": []}, {"name": "Privilege Escalation", "id": "Privilege Escalation", "path": "/tactics/TA0111/", "children": []}, {"name": "Evasion", "id": "Evasion", "path": "/tactics/TA0103/", "children": []}, {"name": "Discovery", "id": "Discovery", "path": "/tactics/TA0102/", "children": []}, {"name": "Lateral Movement", "id": "Lateral Movement", "path": "/tactics/TA0109/", "children": []}, {"name": "Collection", "id": "Collection", "path": "/tactics/TA0100/", "children": []}, {"name": "Command and Control", "id": "Command and Control", "path": "/tactics/TA0101/", "children": []}, {"name": "Inhibit Response Function", "id": "Inhibit Response Function", "path": "/tactics/TA0107/", "children": []}, {"name": "Impair Process Control", "id": "Impair Process Control", "path": "/tactics/TA0106/", "children": []}, {"name": "Impact", "id": "Impact", "path": "/tactics/TA0105/", "children": []}]}]}, "domain": "mobile", "notes": null, "deprecated": false, "descr": " The adversary is trying to maintain their foothold.\n\nPersistence is any access, action, or configuration change to a mobile device that gives an attacker a persistent presence on the device. Attackers often will need to maintain access to mobile devices through interruptions such as device reboots and potentially even factory data resets.", "created": "17 October 2018", "modified": "25 April 2025", "techniques_table": [{"tid": "T1398", "descr": "Adversaries may use scripts automatically executed at boot or logon initialization to establish persistence. Initialization scripts are part of the underlying operating system and are not accessible to the user unless the device has been rooted or jailbroken. ", "technique_name": "Boot or Logon Initialization Scripts", "subtechniques": []}, {"tid": "T1577", "descr": "Adversaries may modify applications installed on a device to establish persistent access to a victim. These malicious modifications can be used to make legitimate applications carry out adversary tasks when these applications are in use.\n\nThere are multiple ways an adversary can inject malicious code into applications. One method is by taking advantages of device vulnerabilities, the most well-known being Janus, an Android vulnerability that allows adversaries to add extra bytes to APK (application) and DEX (executable) files without affecting the file's signature. By being able to add arbitrary bytes to valid applications, attackers can seamlessly inject code into genuine executables without the user's knowledge.(Citation: Guardsquare Janus)\n\nAdversaries may also rebuild applications to include malicious modifications. This can be achieved by decompiling the genuine application, merging it with the malicious code, and recompiling it.(Citation: CheckPoint Agent Smith)\n\nAdversaries may also take action to conceal modifications to application executables and bypass user consent. These actions include altering modifications to appear as an update or exploiting vulnerabilities that allow activities of the malicious application to run inside a system application.(Citation: CheckPoint Agent Smith)", "technique_name": "Compromise Application Executable", "subtechniques": []}, {"tid": "T1645", "descr": "Adversaries may modify system software binaries to establish persistent access to devices. System software binaries are used by the underlying operating system and users over adb or terminal emulators. \n\nAdversaries may make modifications to client software binaries to carry out malicious tasks when those binaries are executed. For example, malware may come with a pre-compiled malicious binary intended to overwrite the genuine one on the device. Since these binaries may be routinely executed by the system or user, the adversary can leverage this for persistent access to the device. ", "technique_name": "Compromise Client Software Binary", "subtechniques": []}, {"tid": "T1624", "descr": "Adversaries may establish persistence using system mechanisms that trigger execution based on specific events. Mobile operating systems have means to subscribe to events such as receiving an SMS message, device boot completion, or other device activities. \n\nAdversaries may abuse these mechanisms as a means of maintaining persistent access to a victim via automatically and repeatedly executing malicious code. After gaining access to a victim\u2019s system, adversaries may create or modify event triggers to point to malicious content that will be executed whenever the event trigger is invoked. ", "technique_name": "Event Triggered Execution", "subtechniques": [{"name": "Broadcast Receivers", "id": "001", "descr": "Adversaries may establish persistence using system mechanisms that trigger execution based on specific events. Mobile operating systems have means to subscribe to events such as receiving an SMS message, device boot completion, or other device activities. \n\nAn intent is a message passed between Android applications or system components. Applications can register to receive broadcast intents at runtime, which are system-wide intents delivered to each app when certain events happen on the device, such as network changes or the user unlocking the screen. Malicious applications can then trigger certain actions within the app based on which broadcast intent was received. \n\nIn addition to Android system intents, malicious applications can register for intents broadcasted by other applications. This allows the malware to respond based on actions in other applications. This behavior typically indicates a more intimate knowledge, or potentially the targeting of specific devices, users, or applications. \n\nIn Android 8 (API level 26), broadcast intent behavior was changed, limiting the implicit intents that applications can register for in the manifest. In most cases, applications that register through the manifest will no longer receive the broadcasts. Now, applications must register context-specific broadcast receivers while the user is actively using the app.(Citation: Android Changes to System Broadcasts) "}]}, {"tid": "T1541", "descr": "Adversaries may abuse Android's `startForeground()` API method to maintain continuous sensor access. Beginning in Android 9, idle applications running in the background no longer have access to device sensors, such as the camera, microphone, and gyroscope.(Citation: Android-SensorsOverview) Applications can retain sensor access by running in the foreground, using Android\u2019s `startForeground()` API method. This informs the system that the user is actively interacting with the application, and it should not be killed. The only requirement to start a foreground service is showing a persistent notification to the user.(Citation: Android-ForegroundServices)\n\nMalicious applications may abuse the `startForeground()` API method to continue running in the foreground, while presenting a notification to the user pretending to be a genuine application. This would allow unhindered access to the device\u2019s sensors, assuming permission has been previously granted.(Citation: BlackHat Sutter Android Foreground 2019)\n\nMalicious applications may also abuse the `startForeground()` API to inform the Android system that the user is actively interacting with the application, thus preventing it from being killed by the low memory killer.(Citation: TrendMicro-Yellow Camera)", "technique_name": "Foreground Persistence", "subtechniques": []}, {"tid": "T1625", "descr": "Adversaries may execute their own malicious payloads by hijacking the way operating systems run applications. Hijacking execution flow can be for the purposes of persistence since this hijacked execution may reoccur over time. \n\nThere are many ways an adversary may hijack the flow of execution. A primary way is by manipulating how the operating system locates programs to be executed. How the operating system locates libraries to be used by a program can also be intercepted. Locations where the operating system looks for programs or resources, such as file directories, could also be poisoned to include malicious payloads.", "technique_name": "Hijack Execution Flow", "subtechniques": [{"name": "System Runtime API Hijacking", "id": "001", "descr": "Adversaries may execute their own malicious payloads by hijacking the way an operating system runs applications. Hijacking execution flow can be for the purposes of persistence since this hijacked execution may reoccur at later points in time. \n\n\nOn Android, adversaries may overwrite the standard OS API library with a malicious alternative to hook into core functions to achieve persistence. By doing this, the adversary\u2019s code will be executed every time the overwritten API function is called by an app on the infected device."}]}, {"tid": "T1603", "descr": "Adversaries may abuse task scheduling functionality to facilitate initial or recurring execution of malicious code. On Android and iOS, APIs and libraries exist to facilitate scheduling tasks to execute at a specified date, time, or interval.\n\nOn Android, the `WorkManager` API allows asynchronous tasks to be scheduled with the system. `WorkManager` was introduced to unify task scheduling on Android, using `JobScheduler`, `GcmNetworkManager`, and `AlarmManager` internally. `WorkManager` offers a lot of flexibility for scheduling, including periodically, one time, or constraint-based (e.g. only when the device is charging).(Citation: Android WorkManager)\n\nOn iOS, the `NSBackgroundActivityScheduler` API allows asynchronous tasks to be scheduled with the system. The tasks can be scheduled to be repeating or non-repeating, however, the system chooses when the tasks will be executed. The app can choose the interval for repeating tasks, or the delay between scheduling and execution for one-time tasks.(Citation: Apple NSBackgroundActivityScheduler)", "technique_name": "Scheduled Task/Job", "subtechniques": []}], "techniques_table_len": "7", "versioning_feature": false}